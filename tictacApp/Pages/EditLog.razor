@page "/logs/{TimeLogId:int}/editLog"
@page "/logs/{TimeLogId:int}/editLogFromProjectSelection"
@page "/logs/{TimeLogId:int}/editLogFromObjectiveSelection"
@page "/logs/{TimeLogId:int}/editLogFromCharacteristicSelection"

@using Helpers
@using Microsoft.EntityFrameworkCore
@using tictacApp.Data
@using tictacApp.Services
@using tictacApp.DataAccess

@inject NavigationManager Navigation
@inject TimeLogsService TimeLogsService
@inject GenericCRUDService<TimeLog> GenericTimelogService
@inject GenericCRUDServiceWithParents<Project> ProjectsService
@inject GenericCRUDServiceWithParents<Objective> ObjectivesService
@inject GenericCRUDServiceWithParents<Characteristic> CharacteristicssService
@inject ItemSelectionService<Project> ProjectSelectionService;
@inject ItemSelectionService<Objective> ObjectiveSelectionService;
@inject ItemSelectionService<Data.Characteristic> CharacteristicSelectionService;
@inject ISnackbar Snackbar

@if (_timeLog is null && !_busy)
{
    <MudAlert Severity="Severity.Error" Variant="Variant.Filled">Could not find the timelog for id: @TimeLogId</MudAlert>
}
else
{
    <TimeLogForm Busy="@_busy" 
                 TimeLog="@_timeLog"
                 IsAdd="false"
                 CancelRequest="Cancel"
                 ValidationResult="@(async (success) => await ValidationResultAsync(success))" />
}

@if (_error)
{
    <MudAlert Class="mt-4" Severity="Severity.Error" Variant="Variant.Filled">@_errorMessage</MudAlert>
}

@code {
    [Parameter]
    public int TimeLogId { get; set; }

    private TimeLog? _timeLog { get; set; } = new TimeLog();

    private TimeLog _dbTimeLog { get; set; } = new TimeLog();

    private TictacDBContext? _dbContext;
    private bool _busy;
    private bool _error;
    private string _errorMessage = string.Empty;
    private bool _concurrencyError = false;


    protected override async Task OnInitializedAsync()
    {
        try
        {
            _busy = true;
            ResetErrorMessage();

            //persists until the component is destroyed as we have to keep the connection until we save or dismiss
            _dbContext  = GenericTimelogService.GetNewDBContext(); 

            string uri = Navigation.Uri;
            SelectionSource source = LogDependenciesSelectionHelper.ComesFromSelection(uri);

            if (source == SelectionSource.Project)
            {
                _timeLog = ProjectSelectionService.EntityBackup;

                _dbContext.Attach(_timeLog);

                if (ProjectSelectionService.HasSelected && ProjectSelectionService.Selection.Any())
                {
                    _timeLog.ProjectId = ProjectSelectionService.Selection.Single().Id;
                }

                ProjectSelectionService.Reset();
            }
            else if (source == SelectionSource.Objective)
            {
                _timeLog = ObjectiveSelectionService.EntityBackup;

                _dbContext.Attach(_timeLog);

                if (ObjectiveSelectionService.HasSelected && ObjectiveSelectionService.Selection.Any())
                {
                    _timeLog.ObjectiveId = ObjectiveSelectionService.Selection.Single().Id;
                }

                ObjectiveSelectionService.Reset();
            }
            else if (source == SelectionSource.Characteristic)
            {
                _timeLog = CharacteristicSelectionService.EntityBackup;

                _dbContext.Attach(_timeLog);

                if (CharacteristicSelectionService.HasSelected && CharacteristicSelectionService.Selection.Any())
                {
                    foreach (Characteristic charact in CharacteristicSelectionService.Selection)
                    {
                        _timeLog.Characteristics.Add(charact);
                    }
                }

                CharacteristicSelectionService.Reset();
            }
            else
            {
                TimeLog? timeLog = await TimeLogsService.FindTimeLogFromIdAsync(_dbContext, TimeLogId);
                if (timeLog != null)
                {
                    _timeLog = timeLog;
                }
                else
                {
                    _error = true;
                    _errorMessage = $"Unable to find the timelog with id: {TimeLogId}";
                }
            }

            if (_timeLog.ProjectId.HasValue)
            {
                string asText = await BreadcrumbHelper.BuildSimpifiedBreadcrumb<Project>(ProjectsService, _timeLog.ProjectId.Value);
                _timeLog.ProjectsAsText = asText;
            }

            if (_timeLog.ObjectiveId.HasValue)
            {
                string asText = await BreadcrumbHelper.BuildSimpifiedBreadcrumb<Objective>(ObjectivesService, _timeLog.ObjectiveId.Value);
                _timeLog.ObjectivesAsText = asText;
            }
            
            if (_timeLog.Characteristics.Any())
            {
                _timeLog.CharacteristicsAsText.Clear();
                foreach (var characteristic in _timeLog.Characteristics)
                {
                    string asText = await BreadcrumbHelper.BuildSimpifiedBreadcrumb<Characteristic>(CharacteristicssService, characteristic.Id);
                    _timeLog.ObjectivesAsText = asText;

                    _timeLog.CharacteristicsAsText.Add(new KeyValuePair<int, string>(characteristic.Id, asText));
                }
            }

        }
        catch (Exception ex)
        {
            _error = true;
            _errorMessage = ex.Message;
        }
        finally
        {
            _busy = false;
        }

        await base.OnInitializedAsync();
    }
    
    private async Task ValidationResultAsync(bool success)
    {
        if (_busy)
        {
            return;
        }

        if (!success)
        {
            Snackbar.Add("Unable to modify the timelog", Severity.Warning);

            _concurrencyError = false;
            ResetErrorMessage();
            return;
        }

        try
        {
            _busy = true; 

            ResetErrorMessage();

            bool savingRes = false;
            if (_dbContext is not null)
            {
                //Management of the many to many relationships, to prevent modification of the entities themselves
                //while we want to update only the many to many intermediate db table
                foreach (Data.Characteristic charToAttach in _timeLog.Characteristics)
                {
                    _dbContext.Entry(charToAttach).State = EntityState.Unchanged;
                }
                foreach (Tag tagToAttach in _timeLog.Tags)
                {
                    _dbContext.Entry(tagToAttach).State = EntityState.Unchanged;
                }

                savingRes = await _dbContext.SaveChangesAsync() > 0;
            }

            if (savingRes )
            {
                Snackbar.Add("Timelog modified successfully", Severity.Success);
                GoBackToList();
            }
            else
            {
                Snackbar.Add("Error when modifying the timelog", Severity.Warning);
            }
        }
        catch (DbUpdateConcurrencyException dbex)
        {
            // concurrency issues!
            _concurrencyError = true;

            // get values from database
            var dbValues = dbex.Entries[0].GetDatabaseValues();

            if (dbValues is null)
            {
                // deleted - show contact not found
                Snackbar.Add("The timelog could not be updated and is not found in DB. It was probably deleted before you saved.", Severity.Warning);
                GoBackToList();
                return;
            }

            // bind to show labels on form
            _timeLog = (TimeLog)dbValues.ToObject();

            // move to original so second submit works (unless there is another concurrent edit)
            dbex.Entries[0].OriginalValues.SetValues(dbValues);
            ResetErrorMessage();
            _busy = false;
        }
        catch (Exception ex)
        {
            _error = true;
            _errorMessage = ex.Message;
        }
        finally
        {
            _busy = false;
        }
    }

    // Back to list.
    private void Cancel()
    {
        GoBackToList();
    }

    private void GoBackToList()
    {
        Navigation.NavigateTo($"/");
    }

    private void ResetErrorMessage()
    {
        _error = false;
        _errorMessage = string.Empty;
    }

    public void Dispose()
    {
        _dbContext?.Dispose();
    }
}